\chapter{重心剖分}
    \section{前言}
    簡單來說就是照著重心把樹給分屍了。\\
    \section{樹重心}
    當樹上有一個點當根時，下面所有子樹大小都不超過整棵樹大小的一半，這個點就是這棵樹的重心。\\
    因此一棵樹會有 1~2 個重心，如果有兩個，那這兩個重心會在隔壁。\\
        \subsection{找重心}
        隨便找一個點當作根開始 DFS，找每個點的子樹大小，然後看他往所有方向的子樹是否超過整顆樹的一半大小。\\
        \begin{C++}
        int n /*整棵樹的大小*/, cen /*重心*/;
        int DFS(int u /*現在的點*/, int f /*爸爸*/){
            int big = 0 /*最大子樹*/, s;
            S[u] = 1; //自己佔一個
            for(int v : T[u]){ //枚舉所有鄰居
                if(v == f) continue; //好馬不吃回頭草
                s = DFS(v, u); //往下遞迴
                S[u] += s /*更新自己大小*/, big = max(big, s) /*更新最大子樹*/;
            }
            if(max(n - S[u], big) << 1 <= n) cen = u; //檢查是否重心
            return S[u]; //回傳自己的子樹大小
        }
        \end{C++}
        時間複雜度 : $O(N)$
    \section{重心樹}
    如同字面上的意思，重心樹是樹重心換個排列。\\
    重心樹的根為原樹的重心。\\
    在原樹上拔掉重心後會分裂成好幾棵大小不超過原樹一半的樹，而這些分裂出去的樹重心就會成為重心樹上根的小孩。\\
    照著這個方法一直做直到原樹上所有點都被丟上重心樹。\\
    \begin{C++}
    //算子樹大小
    int DFS(int u /*現在的點*/){
        int s; 
        S[u] = 1 /*自己佔一個*/, big[u] = 0 /*最大子樹*/;
        for(int v : T[u]){ //枚舉所有鄰居
            if(S[v]) continue; //好馬不吃回頭草
            s = DFS(v); //往下遞迴
            S[u] += s /*更新自己大小*/, big[u] = max(big[u], s) /*更新最大子樹*/;
        }
        V.push_back(u); //點名
        return S[u]; //回傳自己的子樹大小
    }
    //重心剖分
    void CUT(int u /*現在的點*/, int f /*上一個重心*/){
        V.clear(), DFS(u); //算子樹大小
        int n = V.size(), cen /*重心*/;
        for(int v : node){ //枚舉樹上所有點
            if(max(n - S[v], big[v]) << 1 <= n) cen = v; //看是不是重心
            S[v] = 0; //重制
        }
        S[cen] = 1 /*被拔掉了*/, F[cen] = f /*更新重心樹*/;
        for(int v : T[cen]){ //枚舉重心鄰居
            if(!S[v]) CUT(v, cen); //繼續切
        }
    }
    \end{C++}
    時間複雜度 : 在重心樹上每多一層都要把原本整棵樹跑一遍，所以要花 $O(N)$ 的時間，而重心樹每多一層，下一層所有樹大小都至少砍半，因此最多會有 $O(logN)$ 層。總複雜度為 $O(N) \cdot O(logN) = O(NlogN)$
    \section{例子}
    給你一棵 $N$ 個點的 樹，樹上有黑點跟白點，有兩種操作 $Q$ 筆：\\
    1. 把白點變成黑點。\\
    2. 詢問離某個點最近的黑點。\\
    這時候我們可以使用重心樹維護每個節點在重心樹子樹離自己最近的黑點。\\
    更新時就一路往上更新，詢問時也一路往上更新答案。
    因為重心樹最多 $logN$ 層，因此所有操作的複雜度為 $O(QlogN)$
    \section{習題}
        \problem{TIOJ 1171}{
            給你一棵 $N$ 個白點的樹，和 $Q$ 筆操作兩種：\\
            1. 把一個點變黑點。\\
            2.問某一個點跟所有黑點的總距離。\\
            ($N \le 10^5, Q \le 10^6, 1 \le $ 邊權 $\le 10^7$)
        }
        \problem{CSES Fixed-Length Paths I}{
            給你一棵 $N$ 個點的樹，問剛好包含 $K$ 條邊的路徑有幾條。($1 \le K \le N \le 2 \cdot 10^5$)
        }
        \problem{CSES Fixed-Length Paths II}{
            給你一棵 $N$ 個點的樹，問邊數在 $K_1$ 和 $K_2$ 之間的路徑數。
            ($1 \le K_1 \le K_2 \le N \le 2 \cdot 10^5$)
        }
        \problem{CSES Creating Offices}{
            給你一棵 $N$ 個白點的樹，要把一些點塗黑，但兩個黑點間的距離必須大於 $D$，問你最多可以把幾個點塗黑。
            ($1 \le N, D \le 2 \cdot 10^5$)
        }
