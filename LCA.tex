\chapter{LCA和他們的產地}
	\section{前言}
	LCA（Lowest Common Ancestor），最低共同祖先，到底是甚麼呢？當你把一堆生物的親緣關係樹畫出來的時候，你會很想要知道兩種生物的親緣關係接不接近，而最直接的想法就是找出他們的共同祖先嘛！但是他們可能有很多共同祖先，要找哪個好呢？如果找的是很早很早的祖先，那所有的生物都是他的後代，意義並不大，要找的話就是找出他們最低的共同祖先，也就是LCA，才會最有意義。我們可以說，LCA越低的兩個生物，親緣關係越近。
	
	那LCA在CP中有甚麼用武之地呢？？嗯，他跟上面所舉的例子一樣，專門用來處理有關於樹的題目，但處理樹的工具千奇百怪，包括樹鍊剖分啦、重心剖分啦、樹分治、LCT（Link Cut Tree）啦、ETT（Euler Tour Tree）啦、樹壓平啦，LCA可以說是比較基礎的一個主題。而LCA的作法也是各式各樣，接下來都會介紹，而且每個都有每個的好處，千萬不要因為會了其中一個，就對其他的不屑一顧喔！
	
	\section{暴力做LCA}
		如果要暴力去做LCA，相信大家都會：每次詢問兩個節點$A$和$B$的LCA時，紀錄從根到$A$、$B$的路徑成兩個序列，然後找到最前面的節點使得序列不同，這個的前一個就是了（如果都一樣就是根了）。這樣子每次詢問DFS兩次$O(N)$，然後找尋LCA，$O(N)$掃過去即可。
		
		另外一個想法就是：DFS一次紀錄每一個點的父節點和深度，然後每次詢問的時候，不斷把深度小的（一樣就隨便）往上走一次，直到走到一樣為止，這樣複雜度進步為$O(N)$。每次處理都紀錄所有算到的東東就可以大大大減少其複雜度，具體的實作方法：
		$$\text{LCA}(x, y) = \begin{cases}
			x, &\text{for  } x = y\\
			x, &\text{for  } \text{parent[} y \text{]} = x\\
			y, &\text{for  } \text{parent[} x \text{]} = y\\
			\text{LCA(parent[} y \text{], } x \text{)}, &\text{for  } \text{depth[} x \text{]} \leq \text{depth}[y]\\
			\text{LCA(parent[} x \text{], } y \text{)}, &\text{for  } \text{depth[} y \text{]} < \text{depth}[x]
		\end{cases}$$		
		當然，暴力永遠（大部分的時候）不是答案，所以在這裡要介紹各種常見找LCA的方法。
	\section{樹壓平取LCA}
		\subsection{RMQ問題}
			在講LCA之前，首先看個區間的問題：
			\problem{RMQ（區間極值）}{
				給定$N$個數字$a_1, a_2, a_3, \cdots, a_N$，和$Q$個詢問$[l_i, r_i]$，請對於每一個詢問輸出$[l_i, r_i]$內的最大值。
			}
			相信大家都有辦法在不裝弱的前提下容易的寫出$O(NQ)$的解答（寫不出來可能要去面壁思過了），所以通常題目也不會出那麼簡單。這裏具體實作方法不寫（請洽其他章節！），不過用Sparse Table或線段樹等資料結構可以變成$O(N + Q \log N)$或$O(N \log N + Q)$。
		\subsection{歐拉遍歷（Euler Tour）}
			要如何把一個樹變成一個序列呢？一個簡單的想法就是DFS，然後遇到每一個點進去和離開的時候都\inline{push\_back}進去。這個序列會有$1 + 2(N - 1) = 2N - 1$（根先進去，然後每一個邊都加兩次）個元素，並且紀錄每一個點進來和出去的時間戳。這個有什麼性質呢？可以發現，如果$u$是$v$的祖先，則$u$會先放進去，然後$v$進來出來了，$u$才會放第二次。除此之外，還需要紀錄一些額外的東西，待會一一介紹。所以呢，\textbf{對於一個點，其所有子節點的子樹在序列的位置會被包在那個點在序列中的位置兩邊。}如果感覺有一點抽象，那就看個例子吧！（Source: GeeksForGeeks）
			\begin{center}
%				\includegraphics*[width = 0.7\textwidth]{pictures/LCA/eulertour}
			\end{center}
			會需要維護四個陣列：
			\begin{enumerate}
				\item 在序列裡面每一個節點的深度 dep[$x$]
				\item 原本的歐拉遍歷序列 S[$x$]
				\item 每一個節點在序列中第一次出現的位置 first[$x$]（= $\arg \min_{i} (\text{S}[i] = x)$）
				\item 在遍歷序列中，每一個節點所對應到的深度序列 SDep[$x$]（SDep[$i$] = [S[$i$]]）
			\end{enumerate}
			當每次要詢問$a$和$b$的LCA時，找到SDep內的區間$(\text{first[}a\text{]}, \text{first[}b\text{]})$的最小深度所在，假設在$x$，則S[$x$]為答案。用以上的圖解釋，如果想要找$4$和$9$的LCA，則發現first[$3$] = 2（第一次出現在位置為2的地方，在1，2前面）、first[9] = 7。則可以發現，在SDep中（圖中下面的序列），位置為$3$的有最小深度$1$，所以回去看S中位置為3的是誰，發現是2（1，2，4，\textbf{2}），所以回傳2。
			\subsection{為什麼這樣會對？跑的夠快嗎？}
				當想要計算$a$和$b$（first[$a$] $< $ first[$b$]）的LCA時，從S[first[$a$], $\cdots$, first[$b$]]的序列是進入$a$了，然後出去$b$了， 然後往上遞迴，每到他的一個祖先就會遞迴到那個祖先的所有子樹，直到進入了$b$為止。顯然，一旦回溯到了LCA$(a, b)$，即會遞迴到$b$，而到了區間的結尾。所以呢，LCA$(a, b)$在區間裡面，而且它一定是深度最下面的那一個。
				
				至於複雜度，第一次DFS的複雜度是$O(V)$，而如果用線段樹或Sparse Table的話，複雜度差不多是$O(V\log V)$。
	\section{Doubling倍增法}
		Doubling，顧名思義，就是倍增法，聽到倍增法，就可以知道跟二的冪次有關。
		
		Doubling 可以說是LCA的各種做法中最受高中競賽選手歡迎的一種做法。它的好處是code短好刻，又可以在求LCA的時候順便紀錄某一些性質，以便做到某些神奇的事。
		
		話不多說，就直接講做法囉！首先介紹預處理的部分。預處理非常的簡單明瞭，只要記錄兩個簡單的東西：節點的深度，還有每個節點的第$2^k $輩祖先。點的深度相信大家都會，我也不多費唇舌了。至於每個節點的第$2^k $輩祖先，則可以用以下的DP做法簡單求得：
\begin{C++}
anc[root][0] = -1; //根的祖先不存在！
anc[x][0] = pa[0];//第一輩祖先就是父節點 
for(int i = 0;i + 1 < MaxLog; i++)
{
	anc[x][i+1] = anc[anc[x][i]][i]; //anc[i][j]表示第i個節點的第$2^j $輩祖先，若不存在，則為-1
}
\end{C++}
		這樣子看來，預處理的複雜度是$O(N\log N)$($N$是節點數)。
		
		那詢問要如何回答呢？
		
		第一步，想辦法讓兩個要求LCA的節點等高。具體做法就是找出兩者的深度差(稱為$\Delta h$)，並讓較低的節點慢慢上升（每次提升$\Delta h$的二進位中為一的位數所代表的二的冪次，也就是每次都盡量移動多），複雜度$O(\log N)$。Code長這樣：
\begin{C++}
if(dep[a] > dep[b])
	swap(a,b);
int k  = 0;
for(int i = dep[b]-dep[a]; i > 0; i/=2)
{
	if(i % 2 == 1)
		b = anc[b][k];
	k++;
}
\end{C++}
		接下來，基本上就是二分搜了，我們可以知道，若兩個節點深度相同，要找出兩節點的LCA等於找出一個$t$，使兩者的第$t$輩祖先恰好相同，我們二分搜的目標就是這個$t$。更詳細地說，就是從大的二的冪次開始，若兩者的第$2^i$祖先不同，就將兩者轉換為兩者原先的第$2^i$祖先然後繼續。
		\begin{C++}
for(int i = MaxLog-1;i >= 0;i--)
{
	if(anc[a][i] != anc[b][i])
	{
		a = anc[a][i];
		b = anc[b][i];
	}
}
		\end{C++}
		最後的LCA就是 \inline{anc[a][0]}。
		
		一開始有說到可以在倍增法的時候紀錄某些性質，是甚麼意思呢？讓我們直接來看看一個例題：
		\problem{經典題目}{
			給你一個有$N$個節點的樹，其中每條邊都有邊權，並有$Q$筆詢問，每次詢問問你兩個點之間的路徑上所有邊權的最大值。$(N,Q \leq 10^5)$
		}
		
		
		我看到題目的第一個想法就是紀錄從跟開始到每個節點的路徑上的邊權的大值。可是稍微想了一想之後，就會發現這樣做好像沒辦法解決問題（因為$\max$沒辦法好好合併）！
		
		接著，可能就要請出LCA了，能否用doubling呢？然後你就會發現真的可以喔！具體做法就是在預處理的時候順便紀錄每個節點走到他$2^k$輩祖先所經過的路徑中的邊權最大值，之後在處理詢問的時候，就可以在向上跳躍的過程中順便找出跳躍過的這一大堆路徑最大值中的最大值囉！
	
	\section{Tarjan的離線LCA演算法}
		\subsection{演算法敘述}
		可能聰明的讀者有聽說過Tarjan這個人的名字！他對演算法學的貢獻不只在這裏，他有更為人知的求割點的演算法，但是這裏要介紹的是他的離線LCA求法。顧名思義，他的演算法雖然很快（幾乎線性！），但是必須離線，也就是需要事先知道需要查詢哪些點對。
		
		他的作法運用到了並查集（Disjoint Sets），所以會用到其基本的操作（你們應該會並查集，放在這裡只是複習用）：
		\theorem{並查集所支持的操作}{
			\begin{enumerate}
				\item \inline{Find(x)}：找到$x$的代表
				\item \inline{Union(x, y)} ：將$x$、$y$合併成為同一個集合
			\end{enumerate}
		}
		那假設想要詢問的LCA是$Q = \{(u_1, v_1), (u_2, v_2), \cdots, (u_n, v_n)\}$，那進行以下演算法：從根開始先DFS一次，DFS完一個子節點即將子節點的代表設定為自己，而當遞迴完所有的
		
		對於目前節點$u$的每一個子節點$v$先遞迴下去，然後將$v$的代表變成$u$。然後將$u$的顏色（自己設定的值，類似\inline{visited}）設定為$1$，也就是黑色（一開始全部都是$0$，白色）。可以發現，\textbf{一個節點為黑色若且唯若其所有的子樹都被遞迴完了}。
		\subsection{兩個奇怪的操作}
		可是，為什麼要做設定代表和判斷顏色這兩個奇怪的操作呢？
		首先，設定$v$的代表的意思就是：每搜到一個$v$的祖先$x$，則會將\inline{Find(}$v$\inline{)}設定為$x$，代表搜到其他$x$的子樹內，如果有問到$v$而且沒有在之前就就回答到了，那個詢問的答案就是$x$，而且$x$的子樹也都一樣，這個操作利用並查集剛好可以快速實作。
		
		第二，顏色的問題就比較簡單了，就是想要比較晚的來問而已，晚來的會問早來的，而首次（也就是要回答的那一次）問的時候就是被他們的LCA遞迴的時候，此時$dsu[$早來的$]$就會是他們的LCA。
		\subsection{程式碼}
			看了那麼多，可能你眼花撩亂；那就看簡短的程式碼理解吧（並查集的操作省略）！
		\begin{C++}
vector<vector<int> > children; //各個節點的子節點
vector<vector<int> > queries //各個詢問有那個節點的資料，Ex. 詢問(2, 3)會同時存在queries[2]和queries[3]中。
vector<int> dsu; //並查集
void tarjanLCA(int u){//u為目前的節點
	for(int v : children[u]){
		tarjanLCA(v);
		Union(u, v);
		anc[Find(u)] = u;
	}
	colour[u] = 1;
	for(int v : queries[u]){
		if(colour[v] == 1){
			Find(v);
			//LCA(u, v) = anc[Find(v)]
		}
	}
}
		\end{C++}
	\subsection{複雜度}
		這個在一次DFS即可完成，而且每一個query會被弄到兩次，所以會很接近線性（超線性）的複雜度（會多一個艾克曼的反函數，一般用途不會超過$4$）的$O((N + Q) \cdot \alpha(N))$，此處$\alpha(N)$是反艾克曼函數。
	\section{樹鍊剖分}
	
	咦！樹鍊剖分，聽起來就很恐怖，到底是啥啊？不用怕，他真的沒有想像中難，他只不過是一種LCA的求法而已嘛！當然，他能做的事當然不只LCA。
	\subsection{何謂樹鍊剖分}
	樹鍊剖分，又稱輕重鍊剖分(Heavy-Light Decomposition)，也是用來處理樹上路徑相關問題的好工具。他是一種把序列上的操作搞到樹上路徑的方法，線段樹可以對序列做的事，他幾乎都可以把它搬到樹上來做(路徑查詢啦、點權更改等等)，真的非常有趣喔！
	\definition{重鍊定義}{
		對於一棵樹的每一個節點$u$，令其子樹的大小為$\text{sz}(u)$，則若存在一個$u$的子節點$v$使得$\frac{\text{sz}(u)}{2} < \text{sz}(v)$，那$u$和$v$就存在一條\textbf{重邊}（圖中粗邊為重邊，細邊為輕邊）。
		\begin{center}
			\includegraphics*[scale = 0.4]{HLD}
		\end{center}
		由圖看出，那些重邊會形成一條鍊，而那些鍊就是所謂的\textbf{重鍊}！
	}
		
	直接講樹鍊剖分沒什麼意思，讓我們直接來看例題吧！
	
	\problem{UVa 12424}{
		
給你一棵$N$個節點的樹，每個節點有一種顏色，和$Q$個操作，每一個操作都是以下兩個的其中之一：
		
\begin{enumerate}
			\item 將某個點的顏色改掉
			\item 查詢兩個節點之間的簡單路徑哪個顏色出現最多次，並且輸出
		
\end{enumerate}
		($N, Q \leq 10^5$，顏色數$\leq 10$)
	}
	看到這個題目，不知道大家有甚麼想法呢？
	首先，套一句老話，如果對這個題目沒有想法，就先思考一下簡單的版本：
	\problem{上一題的簡單辦}{
	給你一個序列，你需要處理兩種操作：
	\begin{enumerate}
		\item  將某個位置的數字改掉
		\item 查詢兩個位置之間哪種數字最多
	\end{enumerate}
	（序列長度、操作數$\leq 10^5$，數字種類$\leq 10$）
	}

	這個問題好像就不那麼難，只要對每一種顏色開一顆支援單點修改，區間找和的資料ㄌ結構(BIT、線段樹等)，每次修改次單點修改，查詢就把$10$種顏色都區間查詢一遍就好了。
	
	回到原本的題目，我們的目標就是\textbf{構造一個節點的序列，使得樹上的一條簡單路徑經過的節點分布在序列中盡量少個連續的區塊}。
	
	若是把樹轉換成一個序列，最直覺的想法就是所謂的\textbf{樹壓平}，也就是\textbf{任意選定一個根後，依照樹的前序遍歷順序（也就是進入時間）將所有節點由小到大排成一個序列}。這樣做的好處就是，一個子樹會落在連續的一段序列中，所以只要知道是哪些序列，然後再對那些序列詢問，就可以化簡成上面的問題了！因此，若這個問題問的是每個子樹最多的顏色，那用樹壓平的方法可以在$O(N+Q\log N)$的複雜度做完。
	
	很可惜的，這題的主要重點是路徑而非子樹，所以不能用樹壓平解決。
	
	通常，\textbf{把無根樹轉為有根樹會有助於解題}，而這麼做之後，兩點之間的簡單路徑就是其中之一向上走到兩者的LCA，再向下走到另一個點。因為如此，LCA在路徑問題中佔了蠻重要的地位。那這題可以用倍增法來解決嗎？利用倍增法的確可以在往上跳的過程中順便進行區間查詢，不過要怎麼把節點變成序列，使得在往上跳的過程中不經過太多區塊？因為每個節點都是往根的方向跳，所以很難構造出這個序列。
	因此，我們在這裡提供另外一種LCA的作法(其實就是樹鍊剖分！)。
	\subsection{用樹鍊剖分解LCA}
	
	首先，DFS第一次找出每個子樹的大小，並對每一個節點找出他子節點中最大子樹是哪一棵，也順便紀錄每個節點的父節點和每個點的深度。
	
	接著進行第二次DFS。注意，我這裡直接把細節都說出來喔！從根節點開始，走向他最大的子樹，接下來繼續，直到走到葉為止，這就是第一條重鍊！走的時候，要順便紀錄每個點所屬的重鍊的最高的點，也可以同時為這些點重新編號（也就是第二次DFS的進入順序，紀錄了新的序列中每個節點在哪裏）。而找出第一條重鍊後，其他不在這條鍊中的點，也要從自己開始找重鍊。這樣說明可能不是很清楚，不過待會看code的時候或許可以體會到喔！
	為甚麼我們要將點重新編號呢？還記得我們的目標是將這顆樹轉換成一個序列嗎？這個新的編號，就是新序列的順序喔！我們終於拿到一個序列了，接著就對這個序列建構一棵線段樹(或是其他資料結構)吧！
	好，預處理到此可說是告一段落。我們做了那麼多事，到底是為了甚麼？先賣個關子，讓我們繼續看下去。
	我們終於要來處理LCA了！在介紹方法之前，我們先來看看會用到剛剛預處理的哪些東西：
	\begin{enumerate}
		\item 每個節點深度 \inline{dep[}$x$\inline{]}
		\item 每個節點自己所在的重鍊中，深度最小的節點 \inline{link\_top[}$x$\inline{]}
		\item 每個原編號轉換成的新編號 \inline{link[}$x$\inline{]}
		\item 每個節點的父節點 \inline{pa[}$x$\inline{]}
	\end{enumerate}
這部分看code蠻好了解的，我就借卦長的code來讓大家看看XD！（Source： http://sunmoon-template.blogspot.com/2015/07/heavy-light-decomposition.html）
	\begin{C++}
#include<vector>
#define MAXN 100005
int siz[MAXN],max_son[MAXN],pa[MAXN],dep[MAXN];
/*節點大小、節點大小最大的孩子、父母節點、深度*/
int link_top[MAXN],link[MAXN],cnt;
/*每個點所在鏈的鏈頭、樹鏈剖分的DFS序、時間戳*/
std::vector<int >G[MAXN];/*用vector存樹*/
void find_max_son(int x){
	siz[x]=1;
	max_son[x]=-1;
	for(auto i : G[x]){
		if( i== pa[x] )continue;
		pa[i] = x;
		dep[i] = dep[x]+1;
		find_max_son(*i);
		if(max_son[x]==-1 || siz[i]>siz[max_son[x]] ) max_son[x] = i;
		siz[x]+= siz[i];
	}
}

void build_link(int x,int top){
	link[x] = ++cnt;/*記錄x點的時間戳*/
	link_top[x]=top;
	if(max_son[x] == -1)return;
	build_link(max_son[x], top);/*優先走訪最大孩子*/
	for(auto i : G[x]){
		if( i==max_son[x] || i == pa[x])continue;
		build_link(i,i);
	}
}
	\end{C++}
	接下來呢？其實很簡單，要找兩點之間的LCA時，首先他判斷這兩點是不是在在同一條重鍊上，如果是的話，那頭的深度小的那點就是LCA囉XD。不是的話怎麼辦？我們可以發現，\textbf{如果把深度比較低的那個點換成它那條重鍊的深度最小的節點的父節點之後，兩者的LCA並不會改變}(因為他跳過的部分絕不可能是LCA)。因此就這樣一直換，直到兩者在同一條重鍊中囉！
	\begin{C++}
int find_lca(int a,int b){
	/*求LCA，可以在過程中對區間進行處理*/
	int ta = link_top[a], tb = link_top[b];
	while(ta!=tb){
		if(dep[ta] < dep[tb]){
			swap(ta, tb);
			swap(a, b);
		}
		//這裡可以對a所在的鏈做區間處理 
		//區間為(link[ta], link[a])
		ta = link_top[ a=pa[ta] ];
	}
	/*最後a,b會在同一條鏈，若a!=b還要在進行一次區間處理*/
	return dep[a] < dep[b] ? a : b;
}
	\end{C++}
	Code中的註解應該也寫得頗為清楚，在將低的節點往上跳的同時，可以順便進行區間操作，因此，我們的UVa 12424這題可以說是得到了大致的解法。
	剩下的問題就是，這麼做的複雜度有比較好嗎？
	\subsection{樹鍊剖分的複雜度分析}
	已知每次進行區間操作的複雜度是$O(\log N)$，那對於每一組要求LCA的點對，總共要進行幾次「跳躍」呢？這裡我們考慮從一條重鍊上的某一個點跳到他所處的重鍊的深度最小的節點(稱作$h$)的父節點(稱作$p$)的時候其子樹的大小，因為$h$的子樹並非$p$的子節點中的最大子樹(否則他們會在同一條重鍊中)，因此$p$必有一個子節點的子樹的大小比$h$的子樹要來的大，因此，每跳躍一次，跳躍後的節點的子樹都會是原本的兩倍以上。就這個角度來看，一個節點總共最多也只能跳$\log N$次，總共有兩個節點，因此跳躍的次數為$O(\log N)$。
	最終，我們可以了解到每次詢問的總複雜度是$O(\log N)$(跳躍次數)$\times$ $O(\log N)$(區間操作複雜度)！
	因此，以上的題目可以在總複雜度$O(N+Q\log^2N)$做完。以下附上程式碼。
	\eeric{
		要注意的是，樹鍊剖分可以套上其他各式各樣資料結構，包括Treap、BIT、線段樹，還有其他持久化資料結構。
	}
	\section{習題}
		仔細思考這些題目有那裏要用到LCA，都是比較難的題目！
		\problem{UVa 11354 Bond （TIOJ 1163）}{
			非常厲害的Ovuvuevuevue Enyetuenwuevue Ugbemugbem Osas（簡稱Osas）要環遊非洲！他選了$N$個城市，編號為$1, 2, 3, \dots, N$，並且他的地圖上寫了其中一些城市間有$M$條雙向的路，長度為$d_i$。他要走$Q$次，每一次想要從$s_i$走到$t_i$。對於一個從$s_i$走到$t_i$的走法，Osas的疲累度就是路徑上經過路中最長的那一個。請問，對於每一個$s_i$和$t_i$，他可以走的最小疲累度為何（也就是對於每一個$s_i$到$t_i$的路徑中，最大路長最小為何）？
			（$1 \leq N \leq 50000$，$1 \leq M \leq 10^5$）
		}
	
		\problem{TIOJ 1798 Can You Arrive？}{
			Osas現在有了困境——到了先進的新加坡（他非洲逛完了），想要搭地鐵前往美食中心，Newton Hawker！但是，他有一個困擾：新加坡有$N$個站，其中被$N-1$條邊連著（恰好是一棵樹！），但是只有$K$種車子行駛，第$i$種車子會在$x_i$到$y_i$之間的唯一路徑往返（因為是樹！），而他現在有$Q$個詢問，請問從編號為$a$的站可不可以經過若干次轉車到達編號為$b$的站？（$K \leq N \leq 10^6$，$Q \leq 10^6$）
		}
	
		\problem{TIOJ 1445 機器人組裝大賽}{
			現在的Osas已經今非昔比，是個科技的人才！他現在參加了一個機器人組裝比賽，其中有$N$個零件，有$M$種方法可以連結它們，第$i$種方法可以連結第$a_i$和$b_i$個零件，代價有$w_i$。但是：他發現比賽場地也有一個勁敵，名稱為Kkwazzawazzakkwaquikkwalaquaza '* Zzabolazza（簡稱Zzabolazza），他已經找到一個最佳的方法連結所有的零件了（也就是代價最小），請幫助Osas，找到一個代價盡量小的零件連接方法（一定要全部連！不行的話輸出\inline{-1}），並且與Zzabolazza的連接方法不完全相同）。
		}