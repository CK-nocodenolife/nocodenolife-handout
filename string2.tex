\chapter{字串超階}
	\section{前言}
		前面已經學過了關於字串的一些知識，譬如KMP演算法，字典樹（Trie）等，這裡會介紹一些更進階的資料結構與演算法來更有效率的處理字串的各種問題，其中非常精妙，值得細嚼慢嚥的讀。
	\section{後綴序列Suffix Array}
		\subsection{什麼是後綴序列？}
			要看後綴序列之前，以防混淆，先定義一下字串的後綴是什麼：
			\definition{後綴}{
				首先，來定義後綴：對於一個字串$S[0\dots n - 1]$，定義其第$i$個後綴為$S[i \dots n - 1]$。可以知道，第$0$個後綴為字串本身，而第$n - 1$個字串就是$S$的最後一個字元。	
			}
			知道後綴是什麼了，就可以定義後綴序列了：
			\definition{後綴序列}{
				對於一個字串$S$，我們將其後綴照字典序排序之後，將後綴序列$SA[i]$定義為「$S$的字典序第$i$小的後綴是第幾個後綴」
			}
			或許有一點抽象，所以我們就來跑一次例子試試看吧！令$S = abaab$，我們可以得到其後綴們：
			\begin{center}
				\begin{tabular}{c  c}
					0&$abaab$\\
					1&$baab$\\
					2&$aab$\\
					3&$ab$\\
					4&$b$\\
				\end{tabular}
			\end{center}
			大家一定都想得到一個很簡單的方法來建這個序列：把東西全部都放進去一個陣列之後\inline{sort}，但是因為兩個字串的比較是$O(N)$（$N$為字串長度），所以這樣複雜度是$O(N^2 \log N)$，如果稍微大一點的字串就會超時。在這裡，我們介紹一個$O(N (\log N)^2)$的演算法，雖然有$O(N \log N)$甚至$O(N)$的演算法，但是都沒那麼好寫，比賽通常也不會壓這個常數，所以就介紹這個簡單一點的版本。
		\subsection{建立後綴序列}
			注意：這裡要排序的一堆字串，不是隨便抓來的隨機字串，而是同一個字串的後綴！我們可以利用這個性質，來對演算法優化。我們的中心概念是「倍增法」：若可以依照前$2^k$個字元排序，能否用這個資訊得到前$2^{k + 1}$個字元的排序？答案是：可以的。假設對於每一個位置$i$，都已經知道對於目前前$2^k$個字元來說，$i$是第幾位（當然如果相同的話就並列），那要怎麼得到下一個是第幾位？
			
			其實很簡單：注意到第$i$個前綴的前$2^{k}$個字元其實就是第$i$個前綴的前$2^{k - 1}$個字元，後面加上第$i + 2^{k - 1}$個前綴的前$2^{k - 1}$個字元。所以，要比較第$i$個前綴的前$2^{k}$個字元和第$j$個前綴的前$2^{k}$個字元那一個比較大就可以用前面所計算的來比較了。
			
			\definition{Rank Array}{
				有些人會叫做$SA^{-1}$，在此稱作$rank$，也就是$SA$的「反函數」，$SA$是給定一個「第幾名」，它跟你說第幾名是誰；而我們這個$rank$陣列則是：給定第$i$個後綴，它會告訴我們它是第幾名。以數學方式來說，對於$0 \leq i < N$，$rank$會滿足：
				$$rank[SA[i]] = i$$  
			}
			
			具體來說，若$L[i][k]$代表第$i$個前綴的前$2^{k}
			$個字元（若沒有則取代為最小字元）是第幾小的。我們想要由$L[i][k]$獲得$L[i][k + 1]$。則因為第$i$個前綴的前$2^{k}$個字元其實就是第$i$個前綴的前$2^{k - 1}$個字元，我們如果要看第$i$個前綴和第$j$個前綴的前$2^{k + 1}$個字元哪一個比較小，先比較前面的：$L[i][k]$和$L[j][k]$。若分不出高下，再比較$L[i + 2^{k}][k]$和$L[j + 2^{k}][k]$，若超出範圍則看$i$和$j$哪一個比較大，大的代表字串長度比較小，放前面。以上會用到$O(N \log N)$的空間，可以滾動掉。時間的部分，可以知道有$O(\log N)$次的計算，每次都需要$O(N \log N)$來排序，所以總時間複雜度$O(N (\log N)^2)$。程式如下：
			\begin{C++}
vector<int> SA, nextrk, rk; //目前的後綴序列，下一個Rank，目前的Rank（第幾個）
int gap, N;

bool cmp(int i, int j){
	if(rk[i] != rk[j]) 
		return rk[i] < rk[j]; //若前面就能比較
	
	i += gap;
	j += gap;
	
	if(i < N && j < N) 
		return rk[i] < rk[j]; //比較後面
	else 
		return i > j; //字串小的放前面
}

void getSA(string s){
	N = s.length();
	SA.resize(N);
	nextrk.resize(N);
	rk.resize(N);
	
	nextrk[0] = 0;
	
	for(int i = 0; i < N; i++){ //初始化，待會就會sort掉了
		SA[i] = i;
		rk[i] = s[i] - 'a';
	}
	
	for(gap = 1;; gap *= 2){ //gap就是一次看幾個字串
		sort(SA.begin(), SA.end(), cmp);
		for(int i = 1; i < N; i++) 
			nextrk[i] = nextrk[i-1] + cmp(SA[i - 1], SA[i]); //若不同了，就要加一
		for(int i = 0; i < N; i++) 
			rk[SA[i]] = nextrk[i]; //更新Rank
		if(nextrk[N - 1] == N - 1) break; //結束條件
	}
}
			\end{C++}		
		\subsection{$O(N \log N)$建立後綴序列}
		嗯，剛剛的$quick sort$還真的不錯，但畢竟時間複雜度很難唸，而且複雜度為$O(N \log N)$的解也沒有難(長)太多，所以就不學白不學囉！其實做法跟剛剛所敘述的基本上一樣，也是使用倍增法，每次排序一次，只是真的有必要每次都做一次快速排序嗎？
		
		等等，快速排序應該是比較行排序中數一數二快的了吧，還有甚麼排序法比快速排序法更快呢？
		
		大家可能會想到所謂的計數排序(counting sort)可以$O(N+C$(值域))做完排序。那大家不妨想想，這裡每次要排序時的值域多大呢？因為總共要比較兩次$rk$，而所有後綴的$rk$最多有$N$種可能，所以這裡的值域是$O(N^2)$，空間和時間都不允許。
		
		那還有甚麼排序方式呢？如果要排序值域界在$1$到$100$之間的整數，真的只能開$100$格來做counting sort嗎？有沒有可能只開十格或二十格？其實有一種作法叫做radix sort，不知道大家知不知道？假設要排序的數值都是以十進位制表示的二位整數，我們就開兩個十個格子的陣列$A$、$B$，先做個位數再十位數。第一次把每個整數$a_i$丟到$A[a_i\%10]$。第二次的時候從$A[0]$的最底部(最早被丟進去的)開始往上看，再依序看$A[1]$到$A[9]$，也都是由底部往上看。這次，依照被看到的順序將每個整數$a_i$丟到$B[a_i/10]$。做完之後，從$B[0]$的最底部開始往上、往右看，將看到的數字依序記錄下來，就是排序好的序列了。大家可能不太懂，可以參考這個動畫：\url{https://www.youtube.com/watch?v=xuU-DS_5Z4g}。這真的是一個很神奇的方法，我一開始聽到的時候也沒有完全理解他為甚麼會對，但是自己動手畫畫看，就應該可以理解其中的奧妙了。它的複雜度應該是$O(($開的格字數$+$序列長度$) \times$進行輪數$)$。
		
		好，說了這麼多，不知道大家有沒有了解為什麼在這裡上radix sort會使複雜度變好。那我們就將目前的狀況代入它的複雜度中吧！好，首先序列長度不用說，就是字串長度$N$嘛，而進行輪數就是$2$(比較前半段和後半段)，那我們要開幾格呢？因為每一輪都只要依照前半段或後半段的$rk$將其塞到對應的格子中，$rk$右最多只有$N$種，所以只要開$N$個格子就好了！因此複雜度是$O((N+N) \times 2) = O(N)$，就這樣，一個$\log$就被壓掉了！
		
		但實做上還是有一些技巧可以使用，就先煩請大家先稍微看一下code有那裡不懂，在code後我會再詳細解釋。
		\begin{C++}
#define dictsz 200000
//這裡假設有200000種字元
int gap, N;
vector<int> SA, nextrk, rk, temp, cnt;
bool cmp(int i, int j){
	if(rk[i] != rk[j])
	return rk[i] < rk[j]; //若前面就能比較
	
	i += gap;
	j += gap;
	
	if(i < N && j < N)
	return rk[i] < rk[j]; //比較後面
	else
	return i > j; //字串小的放前面
}

void getSA(string s){
	N = s.length();
	SA.resize(N);
	nextrk.resize(N);
	rk.resize(N);
	cnt.resize(dictsz);//這就是桶子啦
	nextrk[0] = 0;
	int i;
	for(i = 0; i < N; i++) //初始化，待會就會sort掉了
		rk[i] = s[i];
	for(i = 0;i < dictsz;i++)
		cnt[i] = 0;//初始化
	for(i = 0;i < N;i++)
		cnt[rk[i]]++;//丟到桶子
	for(i = 1;i < dictsz;i++)
		cnt[i] += cnt[i-1];//待會解釋
	for(i = N-1;i >= 0;i--)
		SA[--cnt[rk[i]]] = i;//待會解釋
	for(gap = 1;; gap *= 2){ //gap就是一次看幾個字元
		temp.clear();
		for(i = N-gap;i < N;i++)
		temp.push_back(i);//後半段會超出的後綴後半段一定最小字典序
		for(i = 0;i < N;i++){
			if(SA[i] >= gap)
			temp.push_back(SA[i]-gap);//將後綴沒有超出的後綴按照字典序丟進去
		}
		//注意，這裡的temp就會依照所有後綴後半段的字典序由小到大排列了
		for(i = 0;i < dictsz;i++)
			cnt[i] = 0;//把桶子清空
		for(i = 0;i < N;i++)
			cnt[rk[temp[i]]]++;//照順序將每個後綴丟到代表其前半段字典序大小的桶子中
		for(i = 1;i < dictsz;i++)
			cnt[i] += cnt[i-1];//做前綴，為甚麼？待會解釋
		for(i = N-1;i >= 0;i--)
			SA[--cnt[rk[temp[i]]]] = temp[i];//這啥？待會解釋
		nextrk[SA[0]] = 0;
		for(i = 1; i < N; i++)
			nextrk[SA[i]] = nextrk[SA[i-1]] + cmp(SA[i - 1], SA[i]); //若不同了，就要加一
		for(i = 0; i < N; i++)
			rk[i] = nextrk[i]; //更新Rank
		if(rk[SA[N - 1]] == N - 1) break; //結束條件
	}
}
		\end{C++}
		
		大家應該可以發現，code跟之前長得差不多。我覺得大家最不能理解的應該就是為甚麼要做前綴，還有這句\inline{SA[--cnt[rk[temp[i]]]] = temp[i]}到底是什麼意思吧？其實這兩件事是一體的。簡單來說，做前綴的目的就是讓要放進去的時候知道要放到$SA$中的哪個位子。再仔細看看上面那行，它的\inline{for}迴圈其實是倒過來寫的，它就是由後往前掃過一遍已經按照後半段排好的後綴，然後$cnt$的前綴值減一不就是它應該放在$SA$中的位置嗎？
	\section{最長共同前綴序列LCP Array}
		\subsection{LCP Array又是什麼？}
			LCP Array是有了後綴序列之後的一個好幫手，可以再次加速演算法！這一次也要先定義所需要的函數：對於兩個字串$A$和$B$，我們定義$lcp(A, B)$為他們兩個的最長共同前綴的長度。
			\definition{LCP Array}{
				對於一個字串$S$和其前綴序列$SA$，我們定義其LCP陣列$LCP[i] = lcp(T_{SA[i]}, T_{SA[i - 1]})$，且$LCP[0] = 0$。此處$T_i$代表$S$的第$i$個前綴。
			}
			當然，不難想到一個$O(N^2)$的計算方法，但是這樣一定太慢！有一個$O(N)$的計算方法，讓我們繼續看下去！
		\subsection{Kasai's Algorithm}
			這個神奇的方法稱為Kasai's Algorithm，能夠在給定字串$S$和其後綴序列$SA$的情況下在$O(N)$算出LCP陣列。首先，我們先定義一個東東：
			
			接下來，這個部分可能你會需要重讀很多遍，因為真的蠻細的；不過搞懂之後，實作不複雜。
			
			Kasai's Algorithm的中心思想在於思考第$i$個後綴與第$i + 1$個後綴的關係：因為只是拿掉前面一個字元，所以會有好性質可以用！
			
			首先，考慮後綴序列裡面的連續兩個位置，稱為$i_1$與$i_1'$。若$lcp(i_1, i_1') = 0$就算了；否則我們可以知道，$T_{i_1}$和$T_{i_1'}$的第一個字元一定相同。所以，如果拔掉第一個字元會怎麼樣？你會發現，$T_{i_1}$拔掉第一個字元不就是$T_{i_1 + 1}$嗎？首先，我們可以知道$lcp(i_1 + 1, i_1' + 1) = lcp(i_1, i_1') - 1$，因為前者只是後者拿掉第一個字元而已，所以顯然是對的。
			
			因為$lcp(i, j) = \min(lcp_i, lcp_{i + 1}, \dots, lcp_{j})$（左邊的$lcp(i, j)$代表$T_i$和$T_j$的最長共同前綴的長度），我們可以知道$lcp(i_1 + 1) \geq lcp(i_1 + 1, i_1' + 1) =lcp(i_1, i_1') - 1$，所以只要從上一個值減一（若不是零的話）計算就好了。注意：這裡有兩個序列：第一個是後綴序列的順序，第二個是原本後綴的順序，此處$T_k$都是代表第$k$個後綴。而因為計算第$T_i$的時候會用到$T_{i -1 }$，所以跑的順序是依照後綴的順序跑的，而不是依照後綴序列的順序跑。程式：
			\begin{C++}
vector<int> SA, lcp;
void getlcp(string s){
	lcp.resize(N);
	vector<int> SAinv;
	SAinv.resize(N);
	for(int i = 0; i < N; i++){
		SAinv[SA[i]] = i;
	}

	int k = 0;
	for(int i = 0; i < N; i++){
		if(!rk[i]){ //若其為第一個，則沒有lcp
			k = 0;
			continue;
		}
		int j = SA[rk[i] - 1]; //拿到後綴序列的上一個
		while(i + k < N && j + k < N && s[i + k] == s[j +k])  		
			k++;  //利用上面的性質硬跑
		lcp[SAinv[i]] = k; //設定，不是lcp[i]！
		if(k) k--; //界是 -1
	}
}
			\end{C++}
		而這個為什麼是$O(N)$呢？因為\inline{k} 除了一次之外，每次都最多減少$1$，所以\inline{while} 迴圈不可能跑太多次，故時間複雜度是$O(N)$。
\section{Burrow-Wheeler Transform}
	\subsection{這是啥？有什麼用？}
		因為在2019的YTP複賽出現過，所以就來介紹一下這個是做什麼的；//TODO
		\theorem{abc}{def}