\chapter{樹堆Treap}
\section{前言}
treap$=$tree(binary search tree)$+$heap，是一種隨機平衡二元搜尋樹，對於任意的序列，他的插入、刪除、查詢操作期望複雜度皆為$O(\log N)$。一般的BST雖然期望深度也是$O(\log N)$，但是只要刻意餵給他排序好的序列，就一定會退化成鍊狀，這就是為什麼我們需要treap了。因為其期望複雜度低且程式碼相對簡單，故有些時候能拿來代替自平衡二元搜尋樹。
\section{原理}
treap不同於一般二元搜尋樹的是，每個節點除了紀錄這個節點的數字（我們稱之為key值）外，同時會記錄一個pri值，\inline{struct}大概長這樣：
\begin{C++}
int randseed=7122;
int rand(){return randseed=randseed*randseed%0xdefaced;}
struct node{
	int key,pri;
	node *l,*r;
	node(){};
	node(int _key):key(_key),pri(rand()){l=r=nullptr;}
};
\end{C++}
樹中的key值會保持BST的性質（所以他是一種二元搜尋樹），pri值則會保持heap（二叉堆）的性質。這樣可以幹嘛呢？？？我們先對這個結構熟悉一下：
\subsection{唯一性}
在介紹二元搜尋樹時，我們知道對於同一組數字建立二元搜尋樹，他可以有很多種不同的樣子。但在treap中當每對key,pri都固定時，其建構出來的treap是唯一的。你可以想像，BST的性質當中可以固定左右的關係（左邊的key值一定小於右邊），而heap的性質中可以固定上下的關係（上面的pri值一定小於下面），上下左右關係都固定的情形下，這棵treap自然就固定了啊！（你說這樣一點都不嚴謹？講的好像我知道怎麼嚴謹證明一樣）
\subsection{當pri值=$1\~{} n$時}
這個情況下，我們可以想像一棵最普通的二元搜尋樹（只有key值），我們依原本節點pri值從$1\~{} n$的順序一一插入，因為越後面插入的節點一定在越下面，因此pri值（$=$插入時間）大的一定在越下面。如此一來，tree和heap的性質就同時都滿足了。換句話說，每個$1\~{} n$的排列各自代表一種插入順序。
\subsection{當pri值隨機時}
根據上面的結論，pri值的大小可以視為插入時間的先後，那如果pri值隨機的話，不就是隨機順序插入的意思嗎？而我們都知道，隨機順序插入的二元搜尋樹，其期望深度$O(\log N)$（深度超過$2\log N$的機率是$\frac{1}{n^2}$），這也就是為什麼他的操作都可以$O(\log N)$達成了。
\section{實作方法}
聽到這裡，你可能會想說：講那麼多，到底要怎麼在操作的同時保持這些性質啊？事實上，維持這個性質的方法有很多，主要有merge-split treap和旋轉式treap。這邊要介紹的是merge-split treap，因為這種方法好刻code又短。\\

merge-split tree顧名思義，需要有merge（合併）、split（分裂）兩個主要操作。而這兩個操作的實作方法其實就是遞迴，要詳細解釋也沒什麼意思，所以就直接切到程式碼的部分吧。
\subsection{merge}
這個操作是要將$a,b$兩個treap合併成一個，\textbf{其中$a$的所有key值都小於$b$}。
\begin{C++}
node *merge(node *a,node *b){ //將根節點為a,b的treap合併
	if(!a) return b; //base case
	if(!b) return a; //base case
	if(a−>pri<b−>pri){
		a−>r=merge(a−>r,b);
		return a;
	}else{
		b−>l=merge(a,b−>l);
		return b;
	} //pri值小的當父節點，大的當子節點。
}
\end{C++}
\subsection{split}
這個操作是要將一個treap的key值$\leq k$的都丟到$a$，其餘$>k$的丟到$b$。
\begin{C++}
void split(node *s,node *&a,int k,node *&b){
	if(!s) a=b=nullptr; //base case
	else if(s−>key<=k) //s的key較小，故s和其左子樹都在左邊
		a=s,split(s−>r,k,a−>r,b); //分割右子樹
	else 
		b=s,split(s−>l,k,a,b−>l); //分割左子樹
}
\end{C++}
\section{延伸操作}
上面兩個操作看起來實在是沒有什麼實際用途，所以我們要來介紹一下利用它們組合而成的延伸操作。
\subsection{\inline{insert}}
\inline{insert}的做法只需要先將原本的treap拆開，再把左、新節點、右依序合併就好了。以下是程式碼：
\begin{C++}
void insert(node *&root,int t){
	node *a,*b;
	split(root,a,t,b);
	root=merge(merge(a,new node(t)),b);
}
\end{C++}
\subsection{\inline{erase}}
\inline{erase}基本上就是反著做\inline{insert}就好了。以下為程式碼：
\begin{C++}
void erase(node *&root,int t){
	node *a,*b,*c;
	split(root,a,t,b);
	root=b;
	split(root,b,t,c);
	root=merge(a,c);
}
\end{C++}
\section{比BST更強大的功能}
treap是一個進階版的BST，因此能改裝成具有更多功能的東西。其中，treap最吸引人的功能就是merge和split了。不過我們先從一些初階的東西開始講起。
\subsection{記錄size}
要記錄每個子樹的size，就是自己的size$=$左子樹的size$+$右子樹的size$+1$。這簡單的運算一切就交給遞迴就好了（事實上就是線段樹的懶標）。這邊就不附上code了（後面會有）。
\subsection{名次樹（rank tree）}
rank tree就是要能查詢各個rank的值以及每個值得rank。在search by key時，可以用兩種方式（假設要查詢key$=k$的rank）：
\begin{enumerate}
\item 將key$\leq k$的split出來，最後根節點的size就是rank了。
%%%%%
\item 同BST的查詢，一開始rank$=1$，每次若不是向左子樹走時rank+=左子樹的size。
%%%%%
\end{enumerate}
而search by rank時，假設要查詢rank$=k$的key值，從根節點開始：如果左子樹的size$+1=$rank，代表此節點的key值就是答案；如果size$\geq $rank,則向左子樹遞迴；如果size$+1<$rank，則向右子樹遞迴，並且rank-=左子樹的size$+1$。
%%%%%
\subsection{split by rank}
既然可以search br rank，下一步就可以split by rank了！作法其實都一樣，只是要記的在遞迴後面加上pull()，才能保持住正確的size。\\

剛剛講了這麼多，重點就是為了下面這個神奇的東西：
\subsection{序列轉treap}
什麼是序列轉treap呢？？？一般而言treap當中都是按照數字大小作為key值，達到BST的效果。然而現在，我們希望這棵treap中序尋訪的結果恰好就是原序列；也就是以index值作為key值。然而我們會知道，其實這邊的key值恰好就會是他的rank，在查詢、split時都可以用rank來進行就好，所以我們通常將key值省略不記（到後面你就會知道記與不記的差別了）。
\subsection{懶人標記（lazy tag）}
懶標你們一定不陌生，沒錯，他就是在線段樹上出現過的東西。這裡的treap恰好也是紀錄一個序列，所以，當然也可以使用懶標啦！假設我現在要對$[l,r)$進行區間加值，我們可以先利用split by rank將整棵treap進行split，分成$[0,l)$，$[l,r)$，$[r,n)$這三棵treap，然後在$[l,r)$這棵treap的根上打懶標，最後再merge回去，就完成區間加值了。
\subsection{區間操作}
從上面的例子你應該可以發現，在treap當中我們可以在$\log N$的時間內切出任意的區間，因此讓區間操作變得非常容易。這邊我們就舉交換區間的例子來讓大家更深刻體會treap的美妙吧！
\problem{交換區間}{
給定一序列及兩種操作：
\begin{enumerate}
\item 將$[l_1,r_1)$，$[l_2,r_2)$兩個區間的位置交換。
\item 查詢序列第$k$的數字是多少。
\end{enumerate}
}
每次都要搬動一個區間非常麻煩，但使用treap的話，只要切成$[0,l_1)$，$[l_1,r_1)$，$[r_1,l_2)$，$[l_2,r_2)$，$[r_2,n)$五段，在依$[0,l_1)$，$[l_2,r_2)$，$[r_1,l_2)$，$[l_1,r_1)$，$[r_2,n)$的順序merge回來就好了！是不是很簡單？我們來看code吧：
\begin{C++}
int rs=1e9+7;
int rand(){return rs=(rs*rs)%0xdefaced;}
struct node;
int s(node *a);
struct node{
    int a,pri,si;
    node *l,*r;
    node(){}
    node(int _a):a(_a),si(1),pri(rand()){l=r=nullptr;}
    void pull(){si=s(l)+s(r)+1;}
};
int s(node *a){return a?a->si:0;}
node *merg(node *a,node *b){
    if(!a) return b;
    if(!b) return a;
    if(a->pri<b->pri)
        return a->r=merg(a->r,b),a->pull(),a;
    else
        return b->l=merg(a,b->l),b->pull(),b;
}
void split(node *n,node *&a,int k,node *&b){
    if(!n) return a=b=nullptr,void();
    if(k>s(n->l)+1){
        a=n;
        split(n->r,a->r,k-s(n->l)-1,b);
        a->pull();
    }else{
        b=n;
        split(n->l,a,k,b->l);
        b->pull();
    }
}
int query(node *n,int k){ //0-base
    if(s(n->l)+1==k) return n->a;
    if(s(n->l)+1<k) return k-=s(n->l)+1,query(n->r,k);
    else return query(n->l,k);
}
void change(node *&n,int l1,int r1,int l2,int r2){
	//0-base,[)
    node *a,*b,*c,*d,*e;
    split(n,a,l1,b);n=b;
    split(n,b,r1-l1+1,c);n=c;
    split(n,c,l2-r1+1,d);n=d;
    split(n,d,r2-l2+1,e);
    n=merg(merg(merg(merg(a,d),c),b),e);
}
\end{C++}