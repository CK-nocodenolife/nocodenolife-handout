\chapter{離線處理淺談 - 強大的工具}
如果一個演算法在計算答案之前不需要知道所有輸入，我們稱這個演算法為\textbf{在線}演算法；
反之若在計算答案的時候要先知道所有輸入，我們稱此為\textbf{離線}演算法。
例如插入排序在排序所有數字時可以一個一個讀進來再各自插入，選擇排序則是必須先讀進所有數字後，才能按照順序把最小的數字放到前面。


犧牲了即時更新性所換來的通常是計算量或coding複雜度的減少，我們先以 RMQ 當作一個簡單的例子。
\problem{經典題 - RMQ (ZJ d539)}{
給定一個序列 $a_1, a_2, \dots , a_n$，之後有 $q$ 次詢問 $[l,r]$ 中的最大值。 $n,q\leq 10^5$。
}
我們可以讀進所有詢問$[l,r]$，並依照左界由大到小排序。
如此一來，對於固定的左界只需要維護一個前綴max就足以回答所有詢問，
我們可以想到用 BIT 來維護這個東西，對於左界的遞減剛好對應到單點更新，
就這樣輕鬆完成不須線段樹的 RMQ 啦！雖然這個例子可能不一定能感受到離線演算法的威力，
但大家應該了解到了，如果離線計算的話可以用很多奇怪的方法去減輕時間、空間或coding複雜度。

\section{莫隊(Mo's Algorithm)}
從前面的題目可以發現，在面對一些區間詢問的題目時，有時我們可以藉由將詢問以
某種方式排序來降低操作整體的複雜度，其中有一種演算法稱為\textbf{莫隊}。

莫隊演算法通常適用於那些當區間左右界稍微改變時，能以很小的代價維護新區間的題目，
簡單來說，我們要想辦法排序詢問使得兩兩之間的「距離」都很相近，讓我們可以從前一個詢問的答案用不多的時間推出後一個詢問的答案以節省時間複雜度。
如果能花$F(n)$的時間從$[l,r)$的答案推到$[l\pm 1,r)$或$[l,r\pm 1)$，由$[l_1,r_1)$的答案推出$[l_2,r_2)$的答案所需要的時間就是$F(n)\cdot(|l_2-l_1|+|r_2-r_1|)$，這也可以看成座標平面上兩點的曼哈頓距離，我們可以用曼哈頓最小生成樹的演算法達到最差$O(F(n)\cdot n\sqrt{q})$的複雜度，但是否有更簡單的方法能達到相同的複雜度呢？

我們可以想到先將詢問依照左界排序，這樣當我們要查詢時左界只需要修改最多 $O(n)$，
不過聰明的大家應該會發現右界的順序是亂的！這就會導致我們的修改次數最多會退化至 $O(nq)$，
為了解決這個問題，我們決定也以某種方式對右界排序。

\textbf{我們把原序列分成 $m$ 塊 (每塊有 $n/m$ 個元素)，並且依照左界所在的塊排序，若在同一塊則以右界排序。}
左界在同一塊間的移動次數總和最多就是 $q\cdot n/m$，而不同塊之間的移動次數最多是 $m\cdot 2(n/m) = 2n$；
右界在同一塊間的移動次數總和最多是 $nm$ ，而不同塊之間右界的移動次數最多也同樣是 $nm$；
因此總複雜度為 $O(F(n)\cdot (nq/m+nm+2n))$，可以發現取 $m=\sqrt{q}$ 會得到最佳複雜度 $O(F(n)\cdot n\sqrt{q})$ ，這也和曼哈頓最小生成樹可得到的結果相同，我們通常採用這種寫法。
莫濤提出的莫隊算法，除了將詢問排序之外，剩下都只是暴力計算，但是就是因為把詢問好好排序，得以把複雜度降低了一個根號。

實作上有一些細節，就是在更新左、右界時，盡量不要讓右界比左界小（也就是不要讓區間不合理），這部分的程式碼通常會用數個\inline{while}來實現，其架構大概長的像下面這樣。

\begin{C++}
struct Query{
	int l, r, id, block;
} Q[MAXQ];

bool cmp(Query &a, Query &b){
	return (a.block!=b.block) ? a.block<b.block : a.r<b.r;
}

int n, m, res, ans[MAXQ];
void add(int pos){ ... } // 維護增加一個數的改變
void sub(int pos){ ... } // 維護減少一個數的改變

void MO(){
	int K = 400; // 有時會依範圍直接寫一個固定的大小
	for(int i = 0; i < q; i++) Q[i].block = Q[i].l/K;
	sort(Q, Q+q, cmp); // 有時沒排序也沒過(X
	// 初始化也很重要，要注意一開始的區間
	int l = 1, r = 0;
	for(int i = 0; i < q; i++){
		// 先擴展再縮減
		// 這邊是左閉右閉的區間寫法，邊界問題自己要注意
		while(l > Q[i].l) add(--l);
		while(r < Q[i].r) add(++r);
		while(l < Q[i].l) sub(l++);
		while(r > Q[i].r) sub(r--);
		ans[Q[i].id] = res;
	}
	for(int i = 0; i < q; i++) cout << ans[i] << '\n';
}
\end{C++}

雖然莫隊通常是用來解決不帶修改的題目，但大陸人也有研發出可以解決待修改問題的莫隊，想法大概是把時間視為第三個維度，變成三維曼哈頓距離的感覺(前提是要能在時間軸上前後移動)，用類似的方法可以有 $O(n^\frac{5}{3})$ 的複雜度。
\section{操作分治}
操作分治，又名 CDQ 分治。既然名字裡面有個分治，顧名思義就是利用了 Divide \& Conquer 的算法。
通常我們都希望問題的維度越低越好，但操作分治的做法卻是\textbf{加上了一個時間維度，
對時間分治，並保持其中一個維度有序}，使問題的維度由 $n$ 到 $n+1$ 再降到 $n-1$。

儘管這個想法聽起來莫名其妙，但在處理帶修改的可離線問題時非常有效。
尤其是原本是帶修改的二維問題（加上時間變成三維），可能可以透過操作分治降低複雜度。

實際上操作分治可以分為三個步驟 :
\begin{itemize}
\item 計算左邊區間的答案
\item 計算右邊區間不受左邊區間影響時的答案
\item 計算左邊區間對右邊區間的影響
\end{itemize}
注意這邊是對時間分治，所以左邊右邊代表了時間上的先後；而以上三個步驟的順序也可能會依照題目改變。直接上例題吧！
\problem{經典題(No judge)}{
一個二維平面上，有$n$次操作，每次操作可以在一個點上加上權重，或者詢問某個座標的左下角所有權重的和。 $n\leq 10^5, |x|,|y|\leq 10^9$。
}
離散化是不可避免的，但就算離散化後用二維 BIT 或線段樹依然會 MLE，我們嘗試用操作分治降低問題的維度。

首先依照對每個操作加上一個時間維度，並直接對其分治。對每個區間來說，左右兩個區間的答案會變為兩個子問題，因此我們需要處理的只有「左邊區間的修改」對「右邊區間的查詢」的影響。可以發現，如果按照 $x$ 座標排序好，我們就可以直接動態維護 $y$ 座標前綴和 (BIT) 以得到答案；實作上有點類似merge sort中merge的部分，下面的 code 大概顯示了如何運作。

\begin{C++}
Query Q[MAXQ];
void merges(int L,int M,int R){
	int i = L, j = M;
	vector<query> tmp;
	init(); // BIT
	while(i<M || j<R){
		if((j==R) || ((i<M&&Q[i].x<Q[j].x){
			if(Q[i].type == ADD)
				add(Q[i].y,1); // BIT
			tmp.push_back(Q[i++]);	
		}else{
			if(Q[j]].type == QRY)
				ans[Q[j].id] += query(Q[j].y); // BIT
			tmp.push_back(Q[j++]);
		}
	}
	for(int i=0;i<R-L;i++)
		Q[i+L] = tmp[i];
}
void CDQ(int l=0, int r=n){
	if(r-l == 1) return;
	int mid = l+(r-l)/2;
	CDQ(l,mid),CDQ(mid,r);
	merges(l,mid,r);
}
\end{C++}

每次把一個區間$[l,r)$的兩部份以 BIT 合併求解的複雜度是 $O((r-l)\log n)$ （在離散化的前提下），總時間複雜度$T(n)=2T(n/2)+O(n\log n)$ ，由主定理得知$T(n)=O(n\log^2n)$。

雖然這題可能也可以用動態開點四叉樹或其他奇怪的資料結構解決，但操作分治寫法在空間、coding複雜度都表現得很好，並且時間複雜度的常數也很小。

\section{整體二分搜}
讀到這裡的同學應該都了解什麼是二分搜了吧！二分搜的檢查有時會有些代價，而如果直接各自二分搜這些代價加起來會使複雜度爛掉，我們想辦法讓這些代價能夠共用而減輕複雜度，因此就誕生了\textbf{整體二分搜}的演算法，顧名思義就是整體一起進行二分搜。
\problem{經典題 - 靜態區間第 $k$ 小}{
給定一個序列 $a_1, a_2, \dots , a_n$，之後有 $q$ 個詢問 $(l,r,k)$ ，請對每個詢問輸出 $[l,r]$ 第 $k$ 小的數字。
}
區間第 $k$ 大可能在嵌套或持久化資料結構也會提到，但利用持久化線段樹的寫法空間複雜度很高（筆者寫了兩天還一直MLE，QAQ），也不是我們今天的主題。

類似於\inline{lower\_bound}，考慮對答案二分搜：
每次詢問一個 $x$ 並檢查每個詢問區間有幾個數不大於 $x$ ，如此可以分成答案要比 $x$ 大及答案要比 $x$ 小的兩種詢問；
注意原序列的數也可以分成比 $x$ 大及比 $x$ 小的兩種，
因此能把原序列也分成兩部分，變為兩個子問題遞迴解決。

至於我們要怎麼知道每個區間有多少數不大於 $x$ 呢？
我們可以用 BIT 維護「 $\leq x$ 的數的個數」的前綴和，
如此對於右半部遞迴的前綴和只需要以原序列中大於 $x$ 的數修改前半部遞迴時的 BIT 即可，省下每次都重算原序列或重置BIT的時間複雜度。整體二分的核心程式碼大概長的像這樣(參考自日月卦長的部落格)，當然不同題目一定會需要修改細節部分。
\begin{C++}
// 原序列的數可視為操作一起放進陣列
// V,L,R 是操作們的索引，傳遞 int 比傳遞物件效率好
void totalBinarySearch(int l,int r,vector<int> &V){
	int mid = l+(r-l>>1);	
	vector<int> L,R;
	// 將V中對應的原序列數及詢問以mid為界分到L,R
	split(V,L,R,mid);
	// 二分搜答案不大於 mid 的
	totBS(l,mid,L);
	// 在BIT中記錄不大於 mid 的數造成的影響
	update(L);
	// 二分搜答案大於 mid 的
	totBS(mid+1,R);
	// 復原操作，以免影響到之後的搜索
	undo_update(L);
}
// split的實作，利用BIT
void split(vector<int> &V,vector<int> &L,vector<int> &R,int x){
	for(int id:V){
		if(...){ //是原序列數a_i
			if(a_i < x) {
				add(i,1); // BIT
				L.push_back(id);			
			}else R.push_back(id);
		}
	for(int id:V){
		if(...){ // 是詢問(l,r,k)
			int cnt = query(r)-query(l-1); // BIT
			if(cnt < x) L.push_back(id);
			else R.push_back(id);
		}
	}
	// 離開時記得 undo 讓 BIT 和進來前相同
	undo_update(L);
	V.clear(); // 節省空間
}
\end{C++}

我們來簡單分析一下整體二分搜的複雜度：原序列和詢問都在遞迴樹中出現，每個原序列的數以及每一個詢問出現的次數都是樹高 $O(\log(n+q))$ ，也是 BIT 修改及查詢的時間複雜度，而每次 BIT 修改最多$O(\log n)$（在離散化的前提下），因此我們的均攤時間複雜度是 $O((n+q)\log n\log(n+q))$。整體二分搜的一個明顯優點是空間複雜度低，只有 $O(n+q)$ ，畢竟除了遞迴呼叫使用的空間外也只開了一條 BIT，想當然爾出題者可能藉由記憶體限制的方式強制離線，又因為 code 短且不需要實作持久化樹狀資料結構，因此整體二分在競賽中被廣泛使用。

另外，在這題中由於我們是利用 BIT 來維護，undo 的成本很低，因此可以輕鬆的以 DFS 的方式呼叫遞迴，但有時候對於一些資料結構要 undo 其實是很困難的(例如 DSU)，這時候我們就需要用到 BFS 的技巧。每次操作只在資料結構中增加內容，當二分搜進入新的一層後再將整個資料結構重置，便能避免掉昂貴的 undo 操作。
\section{習題}
習題的唷
\problem{XOR and Favorite Number(CF 617E)}{給定 $k$ 及一個長度為 $n$ 的正整數序列 $s$ ，對於 $Q$ 次詢問 $l, r$ ，每次輸出 $[s_l,\dots s_r]$ 中有幾對 $(i, j)$ 使得 $s_i \oplus s_{i+1} \cdots \oplus s_j = k$，其中 $\oplus$ 代表 XOR 運算。 $n \leq 10^5; s_i, k\leq 10^6$。}
\problem{區間眾數(ZJ b417)}{給定一個長度為 $n$ 的正整數序列 $s$ ，對於 $m$ 次詢問 $l,r$，每次輸出  $[s_l,\dots s_r]$ 眾數的個數以及有幾種數字是眾數。$n,m\leq10^5,1\leq s_i\leq n$。}
\problem{區間逆序數對(TIOJ 1694)}{給定一個長度為 $n$ 的正整數序列 $s$ ，對於 $q$ 次詢問 $l, r$ ，每次輸出 $[s_l,\dots s_r]$ 逆序數對的個數。$n, q \leq 10^6$，$s_i \leq 10^9$。}
\problem{Coding Days (TIOJ 1840)}{給定一長度為$N$的序列以及$Q$筆操作, 每筆操作可能為下列兩種:
\begin{enumerate}
	\item \inline{1 l r k}: 請輸出區間 $[l, r]$ 中第 $k$ 小的值。
	\item \inline{2 p v}: 將序列中的第 $p$ 個值改成 $v$。
	\item \inline{3 x v}: 關於這項操作，詳細的內容請觀察題目敘述。
\end{enumerate}
$N \leq 50000, Q \leq 10000$，序列中的數皆可以用\inline{int}儲存。
}
\problem{Stamp Rally (Atcoder)}{給定一張 $N$ 個點、 $M$ 條邊的無向圖，每條邊編號為$1\~{}M$。有 $Q$ 次詢問 $(x,y,s)$ ，輸出最小的 $i$ ，使得存在分別以 $x$ 和 $y$ 為起點的兩條路徑，路徑上的邊編號都不大於 $i$，且兩條路徑上共有 $s$ 個不同的點（包含 $x,y$ ，可以經過重複的邊或點但不會重複算到）。
$N,M,Q\leq10^5$。
}
