\chapter{塊狀數組（分塊）}
\section{前言}
分塊可以處理 RMQ （區間最小值）的問題，另外也支援單點修改的操作。
\section{暴力美學}
RMQ 的暴力做法是$O(N)$輸入加上$O(N)$暴力掃最小值。另一種暴力求法是對每組(l,r)$O(N)$建二維的表來$O(1)$查詢。但這樣兩種做法在側資量大時會 TLE 。因此我們需要更有效的演算法。
\section{原理}
在上述第二種做法當中，會發現其實有幾段間會被很多組$[l,r)$被用到；也就是說，一段區間詢問可以分成常用的區間加上不常用的區間，而經常使用到的區間可以預處理存下來，以加快詢問速度。當然我們可以用複雜的數學算出預處理哪些區間可以使複雜度最低，但為了簡化，我們多半以數列分塊的形式來解決這個問題。於是我們將整個序列分成$k$段，每段有$\frac{N}{k}$個數字，而這$k$段就視為上述經常被用到的區間。接著存下每段的最小值，如此一來只要詢問包含到這塊的區間，就可以直接存取他的最小值,不必再重算一次了！
\section{操作流程}
\subsection{預處理}
$O(N)$暴力掃一遍，紀錄每個區間的最小值。
\subsection{查詢}
假設詢問區間$[l,r)$的最小值，答案即是每塊被包含於$[l,r)$的區間（直接存取剛剛計算的最小值）以及剩下不滿一個區間的值（暴力掃）。
\subsection{單點修改}
只要修改輸入的點，並更新那塊的最小值（暴力掃），即可$O(\frac{N}{k})$完成。
\subsection{複雜度}
預處理為$O(N)$。查詢時要存取區間內每塊的最小值，複雜度$O(k)$；以及暴力掃不滿一個區間的值，複雜度$O(\frac{N}{k})$。查詢總複雜度為$O(k+\frac{N}{k})$，根據算幾不等式，$k$取為$\sqrt{N}$時複雜度最小，為$O(\sqrt{N})$。故整體為預處理$(O(N)$,詢問$O(\sqrt{N})$的RMQ。
\\\\
以下是程式碼：
\begin{C++}
#define inf 2147483647
#define maxn 100
int a[maxn],b[(int)sqrt(maxn)+1],k;
void init(int n){
    k=(int)sqrt(n);
    for(int i=0;i<(n+k-1)/k;i++)
        b[i]=inf;
    for(int i=0;i<n;i++)
        b[i/k]=min(b[i/k],a[i]);
}
int query(int l,int r){
    int minn=inf;
    while(l%k&&l<=r)
        minn=min(minn,a[l++]);
    while((r+1)%k&&l<=r)
        minn=min(minn,a[r--]);
    while(l<r)
        minn=min(minn,b[l/k]),l+=k;
    return minn;
}
void modify(int ind,int v){
    if(b[ind/k]==a[ind]){
        a[ind]=v;
        b[ind/k]=inf;
        for(int i=(ind/k)*k;i<(ind/k+1)*k;i++)
            b[ind/k]=min(b[ind/k],a[i]);
    }
    a[ind]=v;
}
\end{C++}
\section{其他應用}
分塊可以應用在帶修改區間求和，預處理存下每個區間的和，查詢和RMQ相同，修改則更新該點和該塊的值。詢問複雜度為$O(1)$
\\
而分塊也可以應用到例如區間眾數...等方面。
\section{關於區間修改}
事實上分塊也可以支援區間修改，複雜度$O(\sqrt{N})$。大致上就是b陣列暴力$O(\sqrt{N})$修改。a陣列頭尾不滿一整塊的也是暴力$O(\sqrt{N})$修改，而其他的就分塊打懶標（詳細懶標的觀念可能以後就會提到了吧）。